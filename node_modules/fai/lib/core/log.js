var Colors, FS, LEVEL, Parser, Path, getCaller, getDate, levels, logger;

FS = require('fs');

Path = require('path');

Parser = require('ua-parser');

Colors = require('chalk');

levels = ['trace', 'debug', 'info', 'note', 'warn', 'error'];

LEVEL = String(ﬁ.conf.log).toLowerCase();

if (typeof ﬁ.conf.log !== 'string' || levels.indexOf(LEVEL) === -1) {
  throw ﬁ.error("The level '" + ﬁ.conf.log + "' is not a valid log level.");
}

getCaller = function() {
  var frame, frames, i, j, len, path, prepareStackTrace;
  prepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = function(error, frames) {
    return frames;
  };
  frames = new Error().stack;
  Error.prepareStackTrace = prepareStackTrace;
  for (i = j = 0, len = frames.length; j < len; i = ++j) {
    frame = frames[i];
    path = frame.getFileName();
    if (!path || path === __filename) {
      continue;
    }
    path = path.replace(ﬁ.path.root, '').replace(ﬁ.path.core.ext, '');
    break;
  }
  if (!path) {
    return 'unknown';
  } else {
    return path;
  }
};

getDate = function() {
  var d, hr, to, tz;
  d = new Date();
  to = d.getTimezoneOffset();
  hr = Math.floor(Math.abs(to) / 60);
  tz = d.getTime() + ((hr * (to < 0 ? 1 : -1)) * 3600000);
  return new Date(tz).toISOString().replace(/[TZ]/g, ' ').trim();
};

logger = function(method, args) {
  var allow, caller, colors, head, index, level, path;
  args = Array.prototype.slice.call(args).join(' ');
  if (!ﬁ.util.isString(method)) {
    if (!ﬁ.util.object.isDict(method)) {
      throw new ﬁ.error('Invalid method.');
    }
    caller = method.caller;
    method = method.method;
  }
  colors = [Colors.cyan, Colors.blue, Colors.green, Colors.gray, Colors.yellow, Colors.red];
  index = levels.indexOf(method);
  allow = levels.indexOf(LEVEL);
  level = levels[index][0].toUpperCase();
  if (!ﬁ.util.isString(caller)) {
    caller = getCaller() || '';
  }
  caller = caller.length > 0 ? "[" + caller + "]" : '';
  if (index === -1) {
    throw new ﬁ.error('Invalid log method.');
  }
  if (index < allow) {
    return;
  }
  head = colors[index]([level, getDate(), caller].join(' '));
  process.stdout.write(head + " " + args + "\n");
  if (ﬁ.conf.live) {
    path = Path.join(ﬁ.path.root, ﬁ.conf.name + ".log");
    return FS.appendFile(path, head + " " + args + "\n", function(e) {
      if (e) {
        throw new ﬁ.error(e.message);
      }
    });
  }
};

ﬁ.middleware.append('fi-log', function(request, response, next) {
  var ip, log, ua;
  ip = request.headers['x-forwarded-for'] || request.connection.remoteAddress;
  ua = Parser.parse(request.headers['user-agent']);
  ua = [ua.ua.toString(), ua.os.toString()].join(', ');
  log = {
    method: 'info',
    caller: "REQUEST] [" + ip + "] " + ua + " [" + request.method
  };
  ﬁ.log.custom(log, request.url);
  return next();
});

module.exports = {
  trace: function() {
    return logger('trace', arguments);
  },
  debug: function() {
    return logger('debug', arguments);
  },
  info: function() {
    return logger('info', arguments);
  },
  note: function() {
    return logger('note', arguments);
  },
  warn: function() {
    return logger('warn', arguments);
  },
  error: function() {
    return logger('error', arguments);
  },
  custom: function() {
    var args, method;
    args = Array.prototype.slice.call(arguments);
    method = args.shift();
    return logger(method, args);
  }
};
