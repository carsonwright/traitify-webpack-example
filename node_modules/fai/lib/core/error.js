var Chalk, Coffee, Columnify, FS, FiError, Path, Util, _prepareStackTrace, prepareStackTrace;

Util = require('util');

Path = require('path');

FS = require('fs');

Columnify = require('columnify');

Coffee = require('coffee-script');

Chalk = require('chalk');

_prepareStackTrace = Error.prepareStackTrace;

prepareStackTrace = function(error, frames) {
  var base, color, cont, e, f, file, frame, i, j, k, len, len1, lines, message, name, p, path, paths, pos, ref, s, trace, type;
  lines = [];
  paths = [['module', 'node_modules', Chalk.gray], [ﬁ["package"].name, ﬁ.path.root, Chalk.red], ['app', ﬁ.path.script.root, Chalk.red.bold], ['native', '', Chalk.gray]];
  for (i = j = 0, len = frames.length; j < len; i = ++j) {
    frame = frames[i];
    file = frame.getFileName();
    if (file === __filename) {
      continue;
    }
    path = Path.dirname(file);
    base = paths[paths.length - 1];
    for (k = 0, len1 = paths.length; k < len1; k++) {
      p = paths[k];
      if (!p[1].length || path.indexOf(p[1]) === -1) {
        continue;
      }
      base = p;
      break;
    }
    ref = base, type = ref[0], base = ref[1], color = ref[2];
    if (type === 'module') {
      f = file;
      e = (Path.extname(file)).length * -1;
      base = f.split('node_modules').slice(1).join(':').replace('/:/', ':').slice(1, e);
    } else {
      base = base.length ? file.replace(base, '') : Path.basename(file);
      if (base.indexOf('.') !== -1) {
        base = base.slice(0, Path.extname(base).length * -1);
      }
    }
    pos = [frame.getLineNumber(), frame.getColumnNumber()];
    cont = frame.getFunction();
    if (!cont) {
      continue;
    }
    cont = cont.toString(ﬁ.conf.charset).split(/[\n\r]/)[pos[0] - 1];
    if (!cont) {
      if (!FS.existsSync(file)) {
        continue;
      }
      cont = FS.readFileSync(file, ﬁ.conf.charset);
      if (Path.extname(file).toLowerCase() === '.coffee') {
        cont = Coffee.compile(cont);
      }
      cont = cont.split(/[\n\r]/)[pos[0] - 1];
    }
    cont = cont.slice(pos[1] - 2);
    if ((s = cont.search(/[;{]/)) >= 0) {
      cont = cont.slice(0, s);
    }
    lines.push({
      type: color(type),
      pos: color("[" + pos[0] + ":" + pos[1] + "]"),
      file: color(base),
      cont: color(cont.trim())
    });
  }
  trace = Columnify(lines, {
    showHeaders: false,
    align: 'left'
  });
  name = Chalk.white.bgRed(" " + (error.name || 'Error') + " ");
  message = Chalk.white.bold(" " + error.message + " ");
  return "\n" + name + message + "\n\n" + trace + "\n";
};

FiError = function() {
  var args, error, name;
  this.constructor.super_.prepareStackTrace = prepareStackTrace;
  args = Array.prototype.slice.call(arguments);
  if (args.length > 1) {
    name = args.shift();
  }
  error = this.constructor.super_.apply(this, args);
  error.name = name || this.constructor.name;
  return error;
};

Util.inherits(FiError, Error);

module.exports = FiError;
