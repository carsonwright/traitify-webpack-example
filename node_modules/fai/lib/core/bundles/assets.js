var Axis, CSSo, Coffee, CoffeeProcess, Express, FS, Files, Jeet, Nib, Path, Prefixr, Regex, Route, Rupture, Scramble, Stylus, TmplJS, Types, Uglify, Zlib, tmpdir;

FS = require('fs');

Path = require('path');

Zlib = require('zlib');

Coffee = require('coffee-script');

Stylus = require('stylus');

Axis = require('axis');

Jeet = require('jeet');

Rupture = require('rupture');

Nib = require('nib');

Uglify = require('uglify-js');

Prefixr = require('autoprefixer-stylus');

CSSo = require('csso');

Express = require('express');

Scramble = require('./scramble');

Files = [];

TmplJS = Path.join(ﬁ.path.core.bundles, "template" + ﬁ.path.core.ext);

TmplJS = FS.readFileSync(TmplJS, ﬁ.conf.charset);

tmpdir = Path.join(ﬁ.path.tmp, 'fi-assets');

if (FS.existsSync(tmpdir)) {
  ﬁ.util.fs.dirRemove(tmpdir);
}

FS.mkdirSync(tmpdir);

ﬁ.log.debug("" + tmpdir);

Route = '/static/assets';

Regex = new RegExp(RegExp("^" + Route + "/(js|css)/(\\S+\\.\\1)$"));

ﬁ.middleware.before('fi-server', 'fi-assets', function(request, response, next) {
  var accepts, encode, filename, match, stream;
  if (!(match = Regex.exec(request.url))) {
    return next();
  }
  filename = match[2].replace(/[\\\/]/g, '_');
  if (ﬁ.util.isUndefined(Files[filename])) {
    return next();
  }
  filename = Path.join(tmpdir, filename);
  if (!ﬁ.util.isString(accepts = request.headers['accept-encoding'])) {
    accepts = '';
  }
  response.setHeader('Vary', 'Accept-Encoding');
  response.setHeader('Content-Type', (Express.mime.lookup(request.url)) + "; charset=" + ﬁ.conf.charset);
  if (ﬁ.conf.live) {
    encode = '';
    if (accepts.match(/\bgzip\b/)) {
      encode = 'gzip';
    } else if (accepts.match(/\bdeflate\b/)) {
      encode = 'deflate';
    }
    if (encode.length) {
      response.setHeader('Content-Encoding', encode);
      filename += "." + encode;
    }
  }
  stream = FS.createReadStream(filename);
  stream.on('end', function() {
    stream = void 0;
    return response.end();
  });
  stream.pipe(response);
});

CoffeeProcess = function(orig, pth) {
  var e, error1, ext, file, index, match, path, regex, str;
  str = Coffee.compile(orig, {
    bare: true
  });
  regex = /\s*require\s*\(?\s*[\"\']([^\"\']+)[\"\']\s*\)?\s*/;
  while ((match = str.match(regex)) !== null) {
    file = match[1].replace(/[\\\/]/g, Path.sep);
    ext = Path.extname(file);
    if (!ext.length) {
      file += ﬁ.path.script.ext;
    }
    path = ﬁ.util.array.unique([pth, ﬁ.path.app.master]).filter(function(p) {
      var t;
      p = Path.resolve(Path.join(p, file));
      t = p.replace(ﬁ.path.app.root, '').slice(1);
      ﬁ.log.custom({
        method: 'trace',
        caller: 'ASSETS:JS-REQUIRE'
      }, t);
      return FS.existsSync(p);
    });
    if (!path.length) {
      throw new ﬁ.error("required file could not be found: " + file);
    }
    file = FS.readFileSync(Path.join(path[0], file), ﬁ.conf.charset);
    try {
      if (!ext.length || ext === '.coffee') {
        file = Coffee.compile(file, {
          bare: true
        });
      }
    } catch (error1) {
      e = error1;
      throw new ﬁ.error(e);
    }
    index = TmplJS.indexOf('{{}};');
    file = TmplJS.slice(0, index) + file + TmplJS.slice(index + 5);
    file = file.slice(0, file.lastIndexOf(';'));
    str = str.slice(0, match.index) + file + str.slice(match.index + match[0].length);
  }
  return str;
};

Types = {
  css: {
    ext: ['.styl', '.css'],
    run: function(str, path) {
      var $fai;
      $fai = {
        path: ﬁ.path,
        conf: ﬁ.conf
      };
      return Stylus(str).set('paths', [ﬁ.path.app.root, ﬁ.path.app.master, path]).set('include css', true).define('$fai', $fai, true).use(Rupture()).use(Axis()).use(Jeet())["import"]('jeet').use(Nib()).use(Prefixr()).render();
    },
    min: function(str) {
      return CSSo.justDoIt(str);
    }
  },
  js: {
    ext: ['.coffee', '.js'],
    run: function(str, path, name) {
      return CoffeeProcess(str, path, name);
    },
    min: function(str, path, name) {
      var code;
      code = Uglify.parse(str);
      code.figure_out_scope();
      str = code.transform(Uglify.Compressor({
        warnings: false
      }));
      str.figure_out_scope();
      str.compute_char_frequency();
      str.mangle_names();
      code = void 0;
      return str.print_to_string();
    },
    scramble: function(str) {
      return Scramble(str);
    }
  }
};

module.exports = {
  tree: function(name) {
    var names, part, parts, result, type;
    names = name.split('/');
    result = {
      css: [],
      js: []
    };
    if (!names.length) {
      return result;
    }
    parts = [];
    while ((part = names.shift())) {
      parts.push(part);
      for (type in Types) {
        name = parts.join('_');
        if (!Files[name + ("." + type)]) {
          continue;
        }
        result[type].push(name);
      }
    }
    return result;
  },
  locals: function() {
    var uri;
    uri = function(type, name) {
      return [Route, type, name + '.' + type].join('/');
    };
    return {
      css: function(name) {
        return uri('css', name);
      },
      js: function(name) {
        return uri('js', name);
      }
    };
  },
  store: function(path, name, context) {
    var c, content, deflate, filename, gzip, i, len, normal, ref, results, tmp, type, typename;
    tmp = ﬁ.path;
    ref = String(context).split('.');
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      if (tmp) {
        tmp = tmp[c];
      }
    }
    context = context ? Path.dirname(tmp) : ﬁ.path.app.bundles;
    results = [];
    for (typename in Types) {
      type = Types[typename];
      filename = Path.join(path, name + type.ext[0]);
      if (!FS.existsSync(filename)) {
        continue;
      }
      content = FS.readFileSync(filename, ﬁ.conf.charset);
      content = type.run(content, path, name);
      filename = filename.replace(context, '').substring(1).slice(0, type.ext[0].length * -1);
      if (context === ﬁ.path.app.bundles) {
        filename = filename.slice(0, (name.length + 1) * -1);
      }
      filename = filename.replace(/[\\\/]/g, '_') + type.ext[1];
      Files[filename] = true;
      deflate = function(file, cont, callback) {
        return Zlib.deflate(cont, function(error, buffer) {
          path = Path.join(tmpdir, file + '.deflate');
          if (error) {
            throw new ﬁ.error(error.message);
          }
          return FS.writeFile(path, buffer, function(error) {
            if (error) {
              throw new ﬁ.error(error.message);
            }
            return callback.call(null, file, cont);
          });
        });
      };
      gzip = function(file, cont, callback) {
        return Zlib.gzip(cont, function(error, buffer) {
          path = Path.join(tmpdir, file + '.gzip');
          if (error) {
            throw new ﬁ.error(error.message);
          }
          return FS.writeFile(path, buffer, function(error) {
            if (error) {
              throw new ﬁ.error(error.message);
            }
            return callback.call(null, file, cont);
          });
        });
      };
      normal = function(file, cont, callback) {
        return FS.writeFile(Path.join(tmpdir, file), cont, function(error) {
          if (error) {
            throw new ﬁ.error(error.message);
          }
          return callback.call(null, file, cont);
        });
      };
      if (type.scramble && ﬁ.conf.scramble) {
        ﬁ.log.custom({
          method: 'trace',
          caller: 'scramble:file'
        }, path.replace(ﬁ.path.app.bundles, ''));
        content = type.scramble(content);
      }
      if (ﬁ.conf.live) {
        content = type.min(content, path, name);
        deflate(filename, content, function(file, cont) {
          ﬁ.log.trace('[deflate] ' + file);
          return gzip(file, cont, function(file, cont) {
            ﬁ.log.trace('[gzip] ' + file);
            return normal(file, cont, function(file, cont) {
              ﬁ.log.trace(file);
              return file = cont = void 0;
            });
          });
        });
      } else {
        normal(filename, content, function(file, cont) {
          ﬁ.log.trace(file);
          return file = cont = void 0;
        });
      }
      results.push(filename = content = void 0);
    }
    return results;
  }
};
