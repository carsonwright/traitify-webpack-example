var FS, HTTP, MasterControl, Path, e, error1;

FS = require('fs');

Path = require('path');

HTTP = require('http');

try {
  MasterControl = ﬁ.require('app.master', 'control');
  if (!ﬁ.util.isFunction(MasterControl)) {
    throw new ﬁ.error('Master controller is invalid.');
  }
} catch (error1) {
  e = error1;
  if (e.name === 'FiRequireError') {
    throw new ﬁ.error('Master controller is missing.');
  }
  throw new ﬁ.error(e);
}

module.exports = function(callback) {
  var bundle, error, error2, http, i, j, k, l, len, len1, len2, len3, len4, m, queue, ref, ref1, ref2, route, routes;
  if (!ﬁ.conf.port) {
    return ﬁ.log.warn("A port was not specified, app won't listen.");
  }
  if (ﬁ.isListening) {
    throw new ﬁ.error('ﬁ is already listening.');
  }
  ref = ﬁ.queuePre;
  for (j = 0, len1 = ref.length; j < len1; j++) {
    queue = ref[j];
    if (ﬁ.util.isFunction(queue)) {
      queue();
    }
  }
  ﬁ.server.configure(function() {
    var k, len2, middleware, ref1;
    ref1 = ﬁ.middleware.stack();
    for (k = 0, len2 = ref1.length; k < len2; k++) {
      middleware = ref1[k];
      ﬁ.log.trace("Using middleware: " + middleware.id);
      this.use(middleware.fn);
    }
    return this.use(MasterControl);
  });
  ref1 = ﬁ.queueMid;
  for (k = 0, len2 = ref1.length; k < len2; k++) {
    queue = ref1[k];
    if (ﬁ.util.isFunction(queue)) {
      queue();
    }
  }
  try {
    ﬁ.require('app.root', 'routes');
  } catch (error2) {
    e = error2;
    if (e.name !== 'FiRequireError') {
      throw e;
    }
    throw new ﬁ.error("The route file is invalid or missing.");
  }
  routes = ﬁ.routes.stack();
  len = routes.length - 1;
  error = false;
  ﬁ.bundles = {};
  ﬁ.routes = {};
  if (len > 0 && routes[len].method === 'error') {
    routes[len].method = 'get';
    error = routes[len];
  }
  for (i = l = 0, len3 = routes.length; l < len3; i = ++l) {
    route = routes[i];
    bundle = route.bundle ? route.bundle : '[function]';
    route.controls.unshift(route.route);
    ﬁ.server[route.method].apply(ﬁ.server, route.controls);
    ﬁ.log.custom({
      method: 'debug',
      caller: "ﬁ:" + (route.method.toUpperCase())
    }, route.route + "  →  " + bundle);
    if (!ﬁ.bundles[route.bundle]) {
      ﬁ.bundles[route.bundle] = {};
    }
    ﬁ.bundles[route.bundle][route.method] = route.route;
    if (!ﬁ.routes[route.route]) {
      ﬁ.routes[route.route] = {};
    }
    ﬁ.routes[route.route][route.method] = route.bundle;
  }
  route = i = routes = void 0;
  if (error) {
    ﬁ.server.use(function(errors, request, response, next) {
      request.errors = errors;
      return error.controls[1].call(ﬁ.server, request, response);
    });
  }
  ref2 = ﬁ.queuePost;
  for (m = 0, len4 = ref2.length; m < len4; m++) {
    queue = ref2[m];
    if (ﬁ.util.isFunction(queue)) {
      queue();
    }
  }
  http = ﬁ.server.listen(ﬁ.conf.port, function() {
    ﬁ.isListening = true;
    delete ﬁ.middleware;
    delete ﬁ.queuePre;
    delete ﬁ.queueMid;
    delete ﬁ.queuePost;
    ﬁ.log.custom({
      method: 'info',
      caller: 'fi'
    }, "Listening on " + ﬁ.conf.url);
    FS.writeFileSync(Path.join(ﬁ.path.root, 'fi.lastrun'), new Date());
    ﬁ.route = function() {
      var args, key, method, torepl, val;
      args = Array.prototype.slice.call(arguments);
      bundle = args.shift();
      bundle = bundle[0] === '/' ? bundle.substring(1) : bundle;
      method = typeof args[0] === 'string' ? args.shift() : 'get';
      torepl = args.shift();
      if (!ﬁ.bundles[bundle] || !ﬁ.bundles[bundle][method]) {
        return false;
      }
      route = ﬁ.bundles[bundle][method];
      for (key in torepl) {
        val = torepl[key];
        route = route.replace(":" + key, val);
      }
      return route;
    };
    if (ﬁ.util.isFunction(callback)) {
      return callback.apply(this, arguments);
    }
  });
  return http;
};
